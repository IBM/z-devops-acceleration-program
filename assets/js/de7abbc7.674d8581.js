"use strict";(self.webpackChunkdap_docs=self.webpackChunkdap_docs||[]).push([[370],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>m});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(a),h=i,m=d["".concat(l,".").concat(h)]||d[h]||u[h]||r;return a?n.createElement(m,o(o({ref:t},p),{},{components:a})):n.createElement(m,o({ref:t},p))}));function m(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:i,o[1]=s;for(var c=2;c<r;c++)o[c]=a[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},4197:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var n=a(7462),i=(a(7294),a(3905));const r={},o="Defining dependency management",s={unversionedId:"dependency-management",id:"dependency-management",title:"Defining dependency management",description:"An IT system is developed by many teams and composed of different applications driven by the line of businesses and consumers. Applications need to interact to provide the overall system and interact through defined interfaces. Using well-defined interfaces allows the parts of the application to be worked on independently without necessarily requiring a change in other parts of the system. This application separation is visible and clear in a modern source code management (SCM) system, allowing clear identification of each of the distributed applications. However, in most traditional library managers, the applications all share a set of common libraries, so it is much more difficult to create the isolation.",source:"@site/docs/dependency-management.md",sourceDirName:".",slug:"/dependency-management",permalink:"/z-devops-acceleration-program/docs/dependency-management",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Tutorial",permalink:"/z-devops-acceleration-program/docs/tutorial"},next:{title:"Designing the build strategy",permalink:"/z-devops-acceleration-program/docs/build-strategy"}},l={},c=[{value:"Layout of dependencies of a mainframe application",id:"layout-of-dependencies-of-a-mainframe-application",level:2},{value:"Source dependencies during the build differ from runtime dependencies",id:"source-dependencies-during-the-build-differ-from-runtime-dependencies",level:3},{value:"Programs call each other either dynamically or statically",id:"programs-call-each-other-either-dynamically-or-statically",level:3},{value:"Applications and programs",id:"applications-and-programs",level:2},{value:"Applications and application groups",id:"applications-and-application-groups",level:2},{value:"Cross-cutting interfaces",id:"cross-cutting-interfaces",level:2},{value:"Resources",id:"resources",level:2}],p={toc:c},d="wrapper";function u(e){let{components:t,...r}=e;return(0,i.kt)(d,(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"defining-dependency-management"},"Defining dependency management"),(0,i.kt)("p",null,"An IT system is developed by many teams and composed of different applications driven by the line of businesses and consumers. Applications need to interact to provide the overall system and interact through defined interfaces. Using well-defined interfaces allows the parts of the application to be worked on independently without necessarily requiring a change in other parts of the system. This application separation is visible and clear in a modern source code management (SCM) system, allowing clear identification of each of the distributed applications. However, in most traditional library managers, the applications all share a set of common libraries, so it is much more difficult to create the isolation."),(0,i.kt)("p",null,"This page discusses ways to componentize mainframe applications so they can be separated and the boundaries made more easily visible."),(0,i.kt)("h2",{id:"layout-of-dependencies-of-a-mainframe-application"},"Layout of dependencies of a mainframe application"),(0,i.kt)("p",null,"From a runtime perspective in z/OS, programs run either independently (batch programs) or online in a middleware (CICS, IMS) runtime environment. Programs can use messaging resources like MQ queues or data persistence in the form of database tables, or files. Programs can also call other programs. In z/OS, called programs can either be statically bound or use dynamic linking. If a COBOL program is the first program in a run unit, that COBOL program is the main program. Otherwise, the COBOL program and all other COBOL programs in the run unit are subprograms",(0,i.kt)("sup",{parentName:"p",id:"fnref-1"},(0,i.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1")),". The runtime environment involves various layers, including dependencies expressed between programs and resources or programs and subprograms."),(0,i.kt)("p",null,"There are multiple types of relationships to consider. The source files in the SCM produce the binaries that run on z/OS. To create the binaries, a set of source level dependencies must be understood. There is also a set of dependencies used during run time. These multiple levels of dependencies are defined in different ways, and in some cases not clearly defined at all. Understanding and finding the dependencies in source files is the first challenge."),(0,i.kt)("p",null,"Building a program involves different steps:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Compilation including any pre-compilation steps, defined as explicit steps or as option of the compiler, creates a non-executable binary (object deck) file."),(0,i.kt)("li",{parentName:"ol"},"Link-edit, which assembles the object deck of the program with other objects and runtime libraries as appropriate. Link-edit can be driven by instructions (a link card) from the SCM or as dynamically defined in the build process.")),(0,i.kt)("p",null,"These steps are summarized in the following diagram."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Producing object code and executables",src:a(1042).Z,width:"596",height:"285"})),(0,i.kt)("p",null,"As part of the current build process, some additional steps, such as binds to databases, are sometimes included. The function of these steps is to prepare the runtime for a given execution environment. These should not be included in the build process itself, but should instead be included in the deployment process."),(0,i.kt)("h3",{id:"source-dependencies-during-the-build-differ-from-runtime-dependencies"},"Source dependencies during the build differ from runtime dependencies"),(0,i.kt)("p",null,"Most of the time when people think about an application, it is from a runtime point of view. Several components are required for an application to run. Some of these are required as dependencies such as the database or middleware and its configuration, while others are required as related such as other applications that might be called."),(0,i.kt)("p",null,"Everything running in a runtime environment starts as source from an SCM - or at least, this should be the goal when you consider infrastructure as code. Some source files represent definitions or are scripts that are not required to be built. Those that do require being built generally require other source files such as copybooks, but might not require the CICS definition, for example. Some of the source files are also included in many different programs - for example, a copybook can be used by many programs to represent the shared data structure. It is important to understand the relationships and dependencies between the source files, and when those relationships or dependencies have importance. The copybook is required to build the program, so it is required at compile time, but it is not used during run time. The configuration for a program such as the CICS transaction definition or the database schema is related to the application, but is required only for the runtime environment."),(0,i.kt)("p",null,"A concrete dependency is the interface description when calling a program. A copybook defines the data structure to pass parameters to a program. So, the copybook is important to be shared while the program is part of the implementation."),(0,i.kt)("h3",{id:"programs-call-each-other-either-dynamically-or-statically"},"Programs call each other either dynamically or statically"),(0,i.kt)("p",null,"On z/OS, there are two ways programs are generally called: dynamically and statically. Statically called programs are linked together at build time. These dependencies must be tracked as part of the build process to ensure they are correctly assembled. For dynamic calls, the two programs are totally separate. The programs are built and link-edited separately. At runtime, the subprogram is called based on the library concatenation."),(0,i.kt)("p",null,"Many organizations have been moving to increased usage of dynamic calls as that approach reduces the complexity at build time. However, this approach means that the runtime dependencies need to be tracked and understood if any changes are made that require updates in both program and subprogram."),(0,i.kt)("p",null,"These programs and subprograms are interdependent even when using dynamic calls. When a program calls another program, generally they share data. A transfer of control occurs between the program and the subprogram with the main program passing a set of data to the subprogram and generally expecting some data in response."),(0,i.kt)("p",null,"Different mechanisms exist to share pieces of data based on the language or the runtime. However, there is a need for the caller and the called program to define the data structure to be shared. The call of a subprogram is based on a list of transfer parameters, represented in the interface description like an application programming interface (API), but it is more tightly coupled than today\u2019s APIs that are based on representational state transfer (REST)."),(0,i.kt)("p",null,"Commonly, shared data structure is defined in an included source file - for example, COBOL uses copybooks."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Transfer of control sharing data between a program and subprogram",src:a(520).Z,width:"527",height:"415"})),(0,i.kt)("p",null,"It is very common to define multiple copybooks for programs in order to isolate data structures and reuse them in other areas of an application component. Using copybooks allows more modularity at source level and facilitates dealing with private and shared data structures, or even private or shared functions."),(0,i.kt)("h2",{id:"applications-and-programs"},"Applications and programs"),(0,i.kt)("p",null,"In a web application, it is relatively easy to define an application because the physical artifact that is deployed is the complete representation of such an application: the EAR or WAR file. In the Windows world, it is more complicated since an application can be made of several executables and DLLs, but these are generally packaged together in an installable application or defined by a package manager."),(0,i.kt)("p",null,"An application is generally defined by the function or functions it provides. Sometimes there is a strong mapping between the physical parts that are shipped, and sometimes it is a set of parts that run the application."),(0,i.kt)("p",null,"In the mainframe, we fall closer to the second case where applications are defined by functions. However, based on the way the applications have grown over the years, there may be no clear boundary as to where one application ends and another one begins. An application can be defined physically by a set of resources (load modules, DBRMs, definitions) that belong together as they contribute to the same purpose: the calculation of health insurance policies, customer account management, and so on."),(0,i.kt)("p",null,"At the source file level, the relevant files contributing to an application are derived from the runtime of an application. These files can usually be identified by different means: a set of naming conventions, the ownership, information stored in the SCM, etc. It may not seem obvious at first glance, but most of the time it is possible to define which source files contribute to a given application."),(0,i.kt)("p",null,"Scoping your source files to an application has many benefits. It formalizes the boundaries of the application, and therefore its interfaces; it allows you to define clear ownership; and it helps with the inventory of the portfolio of an organization. Planning of future features to implement should be more accurate based on this scoping."),(0,i.kt)("h2",{id:"applications-and-application-groups"},"Applications and application groups"),(0,i.kt)("p",null,"Within an organization, multiple applications generally make up the business function. An insurance company may have applications dedicated to health insurance, car insurance, personal health, or group health policies. These applications may be managed by different teams, but they must interact. Teams must define the interfaces or contracts between the applications. Today, many of these interactions are tightly coupled with only a shared interface defining the relationship."),(0,i.kt)("p",null,"As we have seen so far, for traditional z/OS applications, the interface is not separate but defined in source via a shared interface definition, generally a copybook or include. This source must be included in each program build for them to be able to interact. With this information, an application can be defined by two main components: shared interfaces that are used to communicate with other programs and the actual implementation of the programs."),(0,i.kt)("p",null,"It is important to note that shared copybooks could be shared not only within an application, but also across programs or across applications. The only way other programs or applications can interact with the program is by including the shared interface definition. A z/OS load module does not work like a Java Archive (JAR) file, because it is does not expose interface definitions."),(0,i.kt)("p",null,"The following diagram illustrates the concept of an application having a private implementation (its inner workings) and a public interface to interact with other programs and applications."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"An application exposes a public interface",src:a(9818).Z,width:"308",height:"270"})),(0,i.kt)("p",null,"As applications communicate, their implementation consumes the public interface of the applications with which they interact. This concept of a public interface is common in Java programs and the way the communication between applications is defined. This principle can also be applied to existing COBOL and PL/I programs to help explain the structure required for a modern SCM, and is illustrated in the following diagram."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Applications consume public interfaces of other applications",src:a(5862).Z,width:"651",height:"548"})),(0,i.kt)("h2",{id:"cross-cutting-interfaces"},"Cross-cutting interfaces"),(0,i.kt)("p",null,"There are additional capabilities that might need to be shared in addition to sets of data structures for application communication. These capabilities might include standard security or logging functions and can be considered cross-cutting interfaces. These capabilities may be developed once and then included in many different programs. It would be very helpful if these additional included capabilities could also be handled as shared components with their own application lifecycle. The challenge comes when these components change in a non-compatible way. These types of changes are generally infrequent but might be needed at times."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Interfaces used by applications, including cross-cutting interfaces",src:a(5049).Z,width:"654",height:"581"})),(0,i.kt)("p",null,"In the preceding sections, we have laid out some of the key factors when considering the source code of traditional mainframe applications. The environment generally consists of many different applications that can provide shared interfaces and could consume shared components, or cross-cutting interfaces."),(0,i.kt)("p",null,"The knowledge of these factors and their respective lifecycles can guide the desired structure of source files in the SCM. Several patterns are possible to provide appropriate isolation, but to also provide appropriate sharing based on different requirements."),(0,i.kt)("h2",{id:"resources"},"Resources"),(0,i.kt)("p",null,"This page contains reformatted excerpts from ",(0,i.kt)("a",{parentName:"p",href:"https://www.ibm.com/support/pages/develop-mainframe-software-opensource-source-code-managers-and-ibm-dependency-based-build"},"Develop Mainframe Software with OpenSource Source code managers and IBM Dependency Based Build"),"."),(0,i.kt)("div",{className:"footnotes"},(0,i.kt)("hr",{parentName:"div"}),(0,i.kt)("ol",{parentName:"div"},(0,i.kt)("li",{parentName:"ol",id:"fn-1"},'See the "Using subprograms" chapter of the ',(0,i.kt)("a",{parentName:"li",href:"https://www-01.ibm.com/support/docview.wss?uid=swg27036733"},"Enterprise COBOL for z/OS documentation library")," programming guide.",(0,i.kt)("a",{parentName:"li",href:"#fnref-1",className:"footnote-backref"},"\u21a9")))))}u.isMDXComponent=!0},5862:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/app-interface-interaction-68e400abc5a62d1103131578569363c3.png"},5049:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/app-interfaces-cross-cut-80af85cdf578c80acfb73a99b3c4b188.png"},9818:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/app-public-interface-82dda5e105da276064a4d9ee0472e60a.png"},1042:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/build-mainframe-app-c58d46361ccba9ccf98efdb60d416cea.png"},520:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/programs-sharing-data-be14b3ad3cee89da612e48d7fac972c3.png"}}]);