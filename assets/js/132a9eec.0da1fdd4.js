"use strict";(self.webpackChunkdap_docs=self.webpackChunkdap_docs||[]).push([[424],{3872:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var t=n(7624),o=n(2172);const a={},s="Planning repository layouts",r={id:"repository-layouts",title:"Planning repository layouts",description:"Because the traditionally large and monolithic nature of enterprise applications can slow down development both at the organizational level and the individual developer level, many enterprises take the migration to Git as an opportunity to examine how they can break their monolithic applications down into more agile functional Git repositories. The repository layout in the source code management (SCM) component of the continuous integration/continuous delivery (CI/CD) pipeline affects other pipeline components in several ways:",source:"@site/docs/repository-layouts.md",sourceDirName:".",slug:"/repository-layouts",permalink:"/z-devops-acceleration-program/docs/repository-layouts",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Courses",permalink:"/z-devops-acceleration-program/docs/courses"},next:{title:"Defining dependency management",permalink:"/z-devops-acceleration-program/docs/dependency-management"}},l={},c=[{value:"Basic components in a Git SCM layout",id:"basic-components-in-a-git-scm-layout",level:2},{value:"Working with Git",id:"working-with-git",level:2},{value:"Visualizing the SCM layout",id:"visualizing-the-scm-layout",level:2},{value:"Guidelines for Git repository scope",id:"guidelines-for-git-repository-scope",level:2},{value:"Managing dependencies between applications",id:"managing-dependencies-between-applications",level:2}];function h(e){const i={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",ul:"ul",...(0,o.M)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.h1,{id:"planning-repository-layouts",children:"Planning repository layouts"}),"\n",(0,t.jsx)(i.p,{children:"Because the traditionally large and monolithic nature of enterprise applications can slow down development both at the organizational level and the individual developer level, many enterprises take the migration to Git as an opportunity to examine how they can break their monolithic applications down into more agile functional Git repositories. The repository layout in the source code management (SCM) component of the continuous integration/continuous delivery (CI/CD) pipeline affects other pipeline components in several ways:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Repository layout affects the developer experience, as it impacts the level of isolation for development activities - in other words, how much of your development can happen independently of code or components managed in other repositories."}),"\n",(0,t.jsx)(i.li,{children:"The scope of the build is typically defined by what is included inside a repository versus outside of it. For shared resources such as copybooks, other repositories might need to be pulled in."}),"\n",(0,t.jsx)(i.li,{children:"The scope of the package sent to the artifact repository will depend on the outputs produced by the build step."}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"basic-components-in-a-git-scm-layout",children:"Basic components in a Git SCM layout"}),"\n",(0,t.jsx)(i.p,{children:"At a high level, the Git SCM can be thought of in two components: the central Git provider, which is the source from which developers will be pulling code from and pushing code to when they do their development work, and the clone on the developer workstation."}),"\n",(0,t.jsx)(i.p,{children:"Within the central Git provider, there can be multiple organizations:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Each organization can have multiple repositories inside it."}),"\n",(0,t.jsx)(i.li,{children:"In turn, each repository can have multiple branches (or versions) of the code in the repository."}),"\n",(0,t.jsxs)(i.li,{children:["Branches enable updates to be isolated within a branch until they are ready to be included in other branches.\nThis allows each developer to focus on their development task on a dedicated branch, only needing to worry about upstream and downstream impacts when they are ready to integrate those with their work.\nBy convention, there is one branch that contains the latest, greatest, and most up-to-date agreed state of the code - this is conventionally known\nas ",(0,t.jsx)(i.code,{children:"main"}),".\nOther branches can exist that represent a past state of the code or new changes that are not yet ready to be included in ",(0,t.jsx)(i.code,{children:"main"}),".","\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Branching in Git is lightweight both in storage space and time - no replication of the entire set of files is required to make a new branch;\nrather, it is a ",(0,t.jsx)(i.em,{children:"copy-on-update"})," scheme that only requires the storage of the differences in files."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"On the developer's workstation, the developer will have however many repositories they have decided to clone down onto their local computer to work with.\nBy default, the clone of the repo from the server is an entire copy of the repo which, for example, includes the same history of changes and all the\nsame branches that exist on the server. When working on changes, the developer will switch their working tree to be the contents of a particular\nbranch."}),"\n",(0,t.jsx)(i.h2,{id:"working-with-git",children:"Working with Git"}),"\n",(0,t.jsx)(i.p,{children:"Git is a distributed version control system, so rather than the files all staying in the mainframe during development, developers will clone the repository they are interested in down to their local workstation. Your organization's administrator(s) can control who has what permissions, or which repositories each developer has access to."}),"\n",(0,t.jsx)(i.p,{children:"Working with a distributed version control system like Git also means that when planning the SCM layout, one factor to consider is size.\nGenerally, you want to avoid doing something like migrating the entire codebase of a large application into one repository."}),"\n",(0,t.jsxs)(i.p,{children:["Large repositories can be cumbersome for a variety of reasons (although there are organizations that successfully manage their\nlarge codebases in so-called ",(0,t.jsx)(i.em,{children:"monorepos"}),").\nFor example, without using more sophisticated Git commands and options, when developers need to clone the repo it will take longer."]}),"\n",(0,t.jsx)(i.h2,{id:"visualizing-the-scm-layout",children:"Visualizing the SCM layout"}),"\n",(0,t.jsx)(i.p,{children:'Traditionally, mainframe applications are often seen as a monolith, but as mentioned previously, it is generally not preferable to have all of your codebase in one giant repository. To begin thinking about how to separate an application "monolith" into different repositories and designing your SCM layout, you can start to think about boundaries within your application, which are formed by things such as responsibilities and ownership.'}),"\n",(0,t.jsx)(i.p,{children:"To use an analogy, you can think of the application like a large capital city. On the surface, it might seem like this city is one big entity - a big monolith. However, upon closer inspection, the city is broken up into districts. And while each district has its own workings (for example, each district has its own school system), all of these districts are connected by a broader infrastructure in a controlled way. There might be public transport, such as a metro or buses, which run on predefined paths and schedules. We can think of this transport infrastructure like the data flowing between application boundaries within a larger system."}),"\n",(0,t.jsx)(i.p,{children:"In a similar sense, the districts within the city could be likened to groupings of related files and programs, which can be formed into their own smaller applications (in a loose sense of the term) with data flowing between them."}),"\n",(0,t.jsx)(i.p,{children:"The following diagram illustrates the point more literally. In this example, there are three applications, which we can again think of like the city districts:"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{alt:"Three applications with interfaces",src:n(116).c+"",width:"651",height:"548"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Each application has its own inner workings in the private implementation (represented by the tan parts of the above diagram). In the city analogy, an example of this could be the school system each district has. In the mainframe context, an example of these inner workings could be the COBOL programs for that application."}),"\n",(0,t.jsx)(i.li,{children:'Additionally, each application needs to be able to communicate with other applications, which is accomplished via its public interface (shown in blue on the diagram). Using the city analogy again, the bus stop for each district could be considered as the district\'s "public interface". In the mainframe context, the public interface could be the copybooks defining data structures that are passed between programs.'}),"\n",(0,t.jsx)(i.li,{children:"Because each application needs to know how to interact with the other applications, the application also includes usage of interfaces from the other applications (shown in red on the diagram). This can be likened to the application needing to know the bus stops and schedule from the other applications."}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Typically, with this layout, each application would have its own Git repository with its own scope. Compared to putting the whole system in a single large Git repository, having these smaller repositories enables more agile development practices. Companies choose a central, web-based repository server where they can manage their repositories, and from which their developers will clone from (for example, Git providers such as GitHub, GitLab, Bitbucket, Azure Repos, and so on). The following section provides some guidance to consider when breaking down a monolithic codebase to achieve this kind of setup."}),"\n",(0,t.jsx)(i.h2,{id:"guidelines-for-git-repository-scope",children:"Guidelines for Git repository scope"}),"\n",(0,t.jsx)(i.p,{children:"The guidelines in this section can be used when considering how to cluster your codebase into Git repositories in a way that makes sense and encourages a streamlined workflow for your organization. There are several factors to balance when scoping repositories, including the following:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Access control","\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Consider who (or which teams) need access to which files. Read/write, read-only, and restricted permissions need to be preserved, and this can be achieved by separating the files into different Git repositories and then managing access accordingly through your Git provider."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["Functional areas of the code","\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"In your current system, if different teams work on different components of your application, it might make sense to make boundaries based on that. An individual can be part of one or several teams."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["Decoupling","\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Consider decoupling applications where it makes sense to do so. This allows different functional areas to have separate release cycles, which can help promote more agility in the overall organization."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["Interfaces","\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"When scoping for Git repository layouts, consider if or how changes performed by a team in one repository might impact other teams. In other words, within a team, if a developer on that team makes a breaking change to their repository (for example, to the application's private implementation), they can just work with their team to fix it. However, if a developer makes breaking changes impacting another team (for example, to the application's public interface), then resolving it can become more complicated."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["Size","\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Consider the scope of changes for a typical change request (or pull request/merge request). For example, it is typically preferable to avoid change requests spanning across multiple repositories. Git providers usually have built-in review and approval mechanisms, so it is recommended to set up the repository layout in a way where these approval and review systems will make sense."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["Performance","\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Git performance can be a consideration, but it should not be the primary driver to make decisions when organizing repository layouts."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"managing-dependencies-between-applications",children:"Managing dependencies between applications"}),"\n",(0,t.jsx)(i.p,{children:"One of the challenges in designing the SCM layout is managing dependencies between applications. For mainframe applications, this means needing to think about how the files are arranged. If a program and its subprogram are located in the same application, then it will be an internal dependency. If they are located in different applications, then the dependency will be external."}),"\n",(0,t.jsx)(i.p,{children:"Languages such as Java allow you to access other external applications by referencing their application programming interfaces (APIs). However, with COBOL (and other mainframe languages), the build process needs to pull in the external dependencies as source, via concatenation. Therefore, this is something you will want to consider when designing your SCM layout."}),"\n",(0,t.jsx)(i.p,{children:"To help guide the SCM layout design process, we can approach the SCM design with a two-step process:"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:['Define which files make up each application: This is like defining the "districts" in your city, if we go back to the city analogy. You can consider looking at boundaries that have already naturally arisen based on ownership and responsibility around different parts of the codebase, in addition to the other ',(0,t.jsx)(i.a,{href:"#guidelines-for-git-repository-scope",children:"guidelines for repository scope"}),".","\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"You might already have an idea of which files make up each application based on a data dictionary."}),"\n",(0,t.jsx)(i.li,{children:"IBM Application Discovery & Delivery Intelligence (ADDI) can assist in visualizing call graphs and clusters of dependencies in your codebase. These visualizations can be useful when you are analyzing the code to figure out how to organize it."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.li,{children:"Understand the internal versus external elements (such as copybooks) for each application: Here, the objective is to identify interfaces and shared items across application scopes - in other words, we want to determine which application is using which copybooks. In the city analogy, this is like identifying the bus stop names. Based on the repository layout, you can minimize how much changes in one repository will impact other repositories (and in turn, other teams and applications). Ideally, you will end up with files that have a lot of references within the same repository."}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"The result of the analysis in the steps above can be reflected within each application's repository. In the following example, you can see that the file structure is organized to indicate private versus public files and interfaces."}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{alt:"An application repository with private and public interfaces organized into different folders",src:n(932).c+"",width:"1718",height:"1329"})}),"\n",(0,t.jsxs)(i.p,{children:["More details about managing dependencies can be found in the documentation for ",(0,t.jsx)(i.a,{href:"/z-devops-acceleration-program/docs/dependency-management",children:"Defining dependency management"}),"."]})]})}function d(e={}){const{wrapper:i}={...(0,o.M)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},116:(e,i,n)=>{n.d(i,{c:()=>t});const t=n.p+"assets/images/app-interface-interaction-68e400abc5a62d1103131578569363c3.png"},932:(e,i,n)=>{n.d(i,{c:()=>t});const t=n.p+"assets/images/branch-contents-7e92b46ce2653232c02be0d3ac1f1b76.png"},2172:(e,i,n)=>{n.d(i,{I:()=>r,M:()=>s});var t=n(1504);const o={},a=t.createContext(o);function s(e){const i=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(a.Provider,{value:i},e.children)}}}]);