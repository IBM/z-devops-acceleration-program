"use strict";(self.webpackChunkdap_docs=self.webpackChunkdap_docs||[]).push([[8916],{5524:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var i=a(7624),t=a(2172);const o={},s="Introduction to branching models",r={id:"branching-models",title:"Introduction to branching models",description:"Git branching models are patterns to enable development teams using Git to manage their code in a streamlined manner. Since Git is established as a de facto standard for source code management (SCM) in the developer community, several approaches were designed to fulfill developers' requirements and manage the application source code lifecycle, with advantages and drawbacks depending on use cases. Based on the experience gained designing branching strategies, the pages in this section describe a blueprint implementation of a mainline-based development approach for mainframe applications using feature branches with an early integration pattern. This setup leverages a standardized development toolset based on an enterprise-wide Git provider and a continuous integration/continuous delivery (CI/CD) toolchain.",source:"@site/docs/branching-models.md",sourceDirName:".",slug:"/branching-models",permalink:"/z-devops-acceleration-program/docs/branching-models",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Defining dependency management",permalink:"/z-devops-acceleration-program/docs/dependency-management"},next:{title:"Git branching model for mainframe development",permalink:"/z-devops-acceleration-program/docs/git-branching-model-for-mainframe-dev"}},l={},d=[{value:"Aims and Assumptions",id:"aims-and-assumptions",level:2},{value:"Choosing a workflow and branching model",id:"choosing-a-workflow-and-branching-model",level:2}];function c(e){const n={a:"a",admonition:"admonition",h1:"h1",h2:"h2",li:"li",p:"p",ul:"ul",...(0,t.M)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"introduction-to-branching-models",children:"Introduction to branching models"}),"\n",(0,i.jsx)(n.p,{children:"Git branching models are patterns to enable development teams using Git to manage their code in a streamlined manner. Since Git is established as a de facto standard for source code management (SCM) in the developer community, several approaches were designed to fulfill developers' requirements and manage the application source code lifecycle, with advantages and drawbacks depending on use cases. Based on the experience gained designing branching strategies, the pages in this section describe a blueprint implementation of a mainline-based development approach for mainframe applications using feature branches with an early integration pattern. This setup leverages a standardized development toolset based on an enterprise-wide Git provider and a continuous integration/continuous delivery (CI/CD) toolchain."}),"\n",(0,i.jsx)(n.p,{children:"A characteristic of this integration pattern is that developers are implementing changes for a planned release and integrate their changes into a common permanent branch (the shared configuration) that is built, tested, and released together as one consistent entity."}),"\n",(0,i.jsxs)(n.p,{children:["The purpose of streamlining both the DevOps solutions and the delivery workflow is to simplify the process for development teams to deliver quality product releases on time. This enables agile development practices that allow the teams to respond more effectively to changes in the market and customer needs. ",(0,i.jsx)(n.a,{href:"/z-devops-acceleration-program/docs/git-branching-model-for-mainframe-dev",children:"The Git branching model for mainframe development"})," introduces the branching model and outlines the development workflow from the developer's perspective. The details of the technical implementation with IBM Dependency Based Build (DBB) and zAppBuild, as well as packaging and deployment, are discussed in ",(0,i.jsx)(n.a,{href:"/z-devops-acceleration-program/docs/branching-model-supporting-pipeline",children:"Pipeline design and implementation supporting the branching model"}),". All branching models are adaptable to the needs of specific teams and their applications. Our branching approach advocates for best practices and indicates where variations can be applied."]}),"\n",(0,i.jsx)(n.p,{children:"The target audience of this branching model documentation is mainframe DevOps architects and SCM specialists interested in learning how to design and implement a CI/CD pipeline with a robust and state-of-the-art development workflow."}),"\n",(0,i.jsx)(n.h2,{id:"aims-and-assumptions",children:"Aims and Assumptions"}),"\n",(0,i.jsx)(n.p,{children:"Some aims and assumptions that guide our recommendations include:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The workflow and branching scheme should both scale up and scale down."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Small teams with simple and infrequent changes will be able to easily understand, adopt, and have a good experience."}),"\n",(0,i.jsx)(n.li,{children:"Large, busy teams with many concurrent activities will be able to plan, track, and execute with maximum agility using the same fundamental principles."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Planning and design activities as well as code development aim to align to a regular release cadence."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:'There is no magic answer to managing large numbers of "in-flight" changes, so planning assumptions should aim as much as possible to complete changes quickly, ideally within one release cycle.'}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:'DevOps/Agile practices typically encourage that, where possible, development teams should strive to break down larger changes into sets of smaller, incremental deliverables that can each be completed within an iteration. This reduces the number of "in-flight" changes, and allows the team to deliver value (end-to-end functionality) more quickly while still building towards a larger development goal.'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"We know it is sometimes unavoidable for work to take longer than one release cycle and we accommodate that as a variant of the base workflow."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"choosing-a-workflow-and-branching-model",children:"Choosing a workflow and branching model"}),"\n",(0,i.jsx)(n.p,{children:"Your choice of workflow and the branching model that supports it need to take into account your team's needs and characteristics."}),"\n",(0,i.jsx)(n.p,{children:"Aspects to consider include:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Size of the team"}),"\n",(0,i.jsx)(n.li,{children:"Frequency of change"}),"\n",(0,i.jsx)(n.li,{children:"Granularity of change"}),"\n",(0,i.jsx)(n.li,{children:"Amount of parallel development"}),"\n",(0,i.jsx)(n.li,{children:"Formality of release process"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The workflows of our recommended ",(0,i.jsx)(n.a,{href:"/z-devops-acceleration-program/docs/git-branching-model-for-mainframe-dev",children:"Git branching model for mainframe development"})," are flexible enough to scale from small teams with an infrequent pattern of small changes, to large and busier teams with many concurrent projects and projects spanning multiple cycles of a formal release cadence. These workflows are supported by the CI/CD pipeline implementation described in ",(0,i.jsx)(n.a,{href:"/z-devops-acceleration-program/docs/branching-model-supporting-pipeline",children:"Pipeline design and implementation supporting the branching model"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,t.M)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},2172:(e,n,a)=>{a.d(n,{I:()=>r,M:()=>s});var i=a(1504);const t={},o=i.createContext(t);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);