"use strict";(self.webpackChunkdap_docs=self.webpackChunkdap_docs||[]).push([[904],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>u});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},d=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},c="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=p(a),m=i,u=c["".concat(s,".").concat(m)]||c[m]||h[m]||o;return a?n.createElement(u,r(r({ref:t},d),{},{components:a})):n.createElement(u,r({ref:t},d))}));function u(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,r=new Array(o);r[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=a[p];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},556:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var n=a(7462),i=(a(7294),a(3905));const o={title:"Supporting pipeline design and implementation"},r="Pipeline design and implementation supporting the branching model",l={unversionedId:"branching-model-supporting-pipeline",id:"branching-model-supporting-pipeline",title:"Supporting pipeline design and implementation",description:"This page details the technical implementation of the different continuous integration/continuous delivery (CI/CD) pipeline types used in the Git branching model for mainframe development. If a branching model workflow demands a specific configuration, it will be covered within the same section.",source:"@site/docs/branching-model-supporting-pipeline.md",sourceDirName:".",slug:"/branching-model-supporting-pipeline",permalink:"/z-devops-acceleration-program/docs/branching-model-supporting-pipeline",draft:!1,tags:[],version:"current",frontMatter:{title:"Supporting pipeline design and implementation"},sidebar:"docsSidebar",previous:{title:"Git branching model for mainframe development",permalink:"/z-devops-acceleration-program/docs/git-branching-model-for-mainframe-dev"},next:{title:"Appendix",permalink:"/z-devops-acceleration-program/docs/branching-appendix"}},s={},p=[{value:"Configurations to support working with feature branches",id:"configurations-to-support-working-with-feature-branches",level:2},{value:"User Build setup",id:"user-build-setup",level:3},{value:"Pipeline build of feature branches",id:"pipeline-build-of-feature-branches",level:3},{value:"Package and Deploy a feature for testing in controlled test environments",id:"package-and-deploy-a-feature-for-testing-in-controlled-test-environments",level:3},{value:"Housekeeping recommendations",id:"housekeeping-recommendations",level:3},{value:"The Basic Build Pipeline for main, epic, and release branches",id:"the-basic-build-pipeline-for-main-epic-and-release-branches",level:2},{value:"Basic Build Pipeline: Build and Test stage",id:"basic-build-pipeline-build-and-test-stage",level:3},{value:"Basic Build Pipeline: Install outputs to a development and test environment",id:"basic-build-pipeline-install-outputs-to-a-development-and-test-environment",level:3},{value:"Basic Build Pipeline: Analyze stage",id:"basic-build-pipeline-analyze-stage",level:3},{value:"The Release Pipeline with Build, Packaging, and Deploy stages",id:"the-release-pipeline-with-build-packaging-and-deploy-stages",level:2},{value:"Release Pipeline: Build stage",id:"release-pipeline-build-stage",level:3},{value:"Release Pipeline: Packaging stage",id:"release-pipeline-packaging-stage",level:3},{value:"Release Pipeline: Deploy stage",id:"release-pipeline-deploy-stage",level:3},{value:"Deployment to production",id:"deployment-to-production",level:2},{value:"Conclusion",id:"conclusion",level:2}],d={toc:p},c="wrapper";function h(e){let{components:t,...o}=e;return(0,i.kt)(c,(0,n.Z)({},d,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"pipeline-design-and-implementation-supporting-the-branching-model"},"Pipeline design and implementation supporting the branching model"),(0,i.kt)("p",null,"This page details the technical implementation of the different continuous integration/continuous delivery (CI/CD) pipeline types used in the ",(0,i.kt)("a",{parentName:"p",href:"/z-devops-acceleration-program/docs/git-branching-model-for-mainframe-dev"},"Git branching model for mainframe development"),". If a branching model workflow demands a specific configuration, it will be covered within the same section."),(0,i.kt)("h2",{id:"configurations-to-support-working-with-feature-branches"},"Configurations to support working with feature branches"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Branching diagram of a feature branch",src:a(8877).Z,width:"183",height:"248"}),"  "),(0,i.kt)("p",null,"When developers start working on a new task, they will first create a feature branch. Feature branches are created off the latest code state of the source configuration, whether that is the ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," branch or an epic or release maintenance branch."),(0,i.kt)("p",null,"If the feature branch was created on the central Git repository, the developers can use the integrated development environment (IDE), a terminal, or another Git interface on their local workstation to clone or pull the new feature branch from the central Git repository. They then switch to the feature branch to implement their changes."),(0,i.kt)("p",null,"IDEs supported by IBM allow developers to perform a Dependency Based Build (DBB) User Build to quickly gather feedback on the implemented changes. This feature is expected to be used before the changes are committed and pushed to the central Git server, where a pipeline can process changes automatically. Developers regularly commit and push their changes to their feature branch on the central Git provider."),(0,i.kt)("h3",{id:"user-build-setup"},"User Build setup"),(0,i.kt)("p",null,"User Build is a capability provided by IBM-supported IDEs that uploads the modified source code and its dependencies from the local, checked-out Git working tree on the developer's workstation to a personal directory on z/OS UNIX System Services, and then invokes the build framework to execute the compile and link-edit steps. This capability is available in the following IDEs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"https://www.ibm.com/docs/en/developer-for-zos"},"IBM Developer for z/OS"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"https://www.ibm.com/docs/en/cloud-paks/z-modernization-stack/2022.2?topic=ide-option-2-developing-vs-code"},"Microsoft Visual Studio Code (VS Code) with the IBM Z Open Editor extension"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"https://www.ibm.com/docs/en/cloud-paks/z-modernization-stack/2022.2?topic=ide-option-1-developing-codeready-workspaces"},"IBM Wazi for Dev Spaces")))),(0,i.kt)("p",null,"The developer configures the User Build process to point to the central build framework implementation, such as ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/IBM/dbb-zappbuild"},"zAppBuild"),", provided by the Mainframe DevOps Team. The build option ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/IBM/dbb-zappbuild/blob/3.2.0/docs/BUILD.md#build-a-single-program"},(0,i.kt)("inlineCode",{parentName:"a"},"--userBuild"))," is passed to the build framework along with the reference to the file the developer would like to build."),(0,i.kt)("p",null,"Because the operation is performed with the credentials of the currently logged-in user, it is recommended for each developer to reuse the high-level qualifier (",(0,i.kt)("inlineCode",{parentName:"p"},"--hlq"),") of their personal datasets. It is the developer's responsibility to regularly clean up the mainframe datasets and sandbox directories on z/OS UNIX System Services that are used for User Build. Automated cleanup of the files can be established based on a defined naming convention for datasets or with a specific storage management policy."),(0,i.kt)("p",null,"User Build is a convenient way to compile and link-edit source code without committing the changes into the Git version control system. Therefore, build outputs of user builds are not assumed to be installed into a runtime environment. To be able to perform simple and rudimentary tests on User Build-generated outputs, the developer should modify the test JCLs to point to the personal libraries used in user builds."),(0,i.kt)("p",null,"Alternatively, the setup of a pre-concatenated runtime library can be implemented to perform more tests in the context of a (shared) test runtime environment. A dedicated pre-concatenated library in the runtime system (for example, batch, IMS and CICS) into which the developers can write allows a separation of the modules produced by user builds, and enables regular cleanup of these intermediate versions that are not yet registered in the central Git provider or as a build output in the artifact repository."),(0,i.kt)("p",null,"External dependencies to other components, such as include files (for example, copybooks or object decks) that are not managed within the application repository but are required for building the application, can either be pulled in via a ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/IBM/dbb-zappbuild/blob/3.2.0/samples/application-conf/Cobol.properties#L83-L89"},"dataset concatenation")," or by the usage of Git submodules, depending on the repository organization."),(0,i.kt)("h3",{id:"pipeline-build-of-feature-branches"},"Pipeline build of feature branches"),(0,i.kt)("p",null,"It is a common practice to use a feature branch pipeline that builds the codebase of a feature branch and runs automated code inspections using the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/IBM/dbb/tree/v2.0.0/Pipeline/RunIDZCodeReview"},"IDz Code Review feature")," and/or updates the static code analysis repository such as in ",(0,i.kt)("a",{parentName:"p",href:"https://www.ibm.com/docs/en/addi/6.1.2?topic=wazi-analyze-user-guide"},"IBM Wazi Analyze"),"."),(0,i.kt)("p",null,"This pipeline expands the scope of the build past that of the user build and makes sure all changed and impacted programs are included in the list of artifacts to be produced by leveraging the ",(0,i.kt)("inlineCode",{parentName:"p"},"--impactBuild")," option of zAppBuild. The developer must make sure to have pushed the feature branch with all their committed changes from their local clone of the repository to the central Git provider so that those changes are available to the feature branch pipeline process."),(0,i.kt)("p",null,"The pipeline configuration requires processing logic to compute a dedicated high-level qualifier to guarantee that build datasets are exclusively used for the provided branch. The computed value is passed into the build command via the ",(0,i.kt)("inlineCode",{parentName:"p"},"--hlq")," parameter. zAppBuild allocates the datasets automatically."),(0,i.kt)("p",null,"The following screen capture shows the stages included a sample pipeline build for a feature branch."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Screen capture of pipeline steps for the feature branch",src:a(3278).Z,width:"490",height:"199"})),(0,i.kt)("p",null,"The build leverages the dependency metadata managed by IBM Dependency Based Build via DBB collections, which are consumed by the build framework, zAppBuild. At the first execution of the build process for feature branches, zAppBuild will duplicate this metadata by cloning the related collections for efficiency purposes",(0,i.kt)("sup",{parentName:"p",id:"fnref-1"},(0,i.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1")),". This cloning phase ensures the accuracy of the dependency information for this pipeline build. To be able to clone the collection, zAppBuild needs to understand which collection contains the most accurate information and should be duplicated. As collection names are derived from the name of the branch, it is easy to identify which collection should be cloned. In the zAppBuild configuration, the originating collection reference is defined via the ",(0,i.kt)("inlineCode",{parentName:"p"},"mainBuildBranch"),(0,i.kt)("sup",{parentName:"p",id:"fnref-1"},(0,i.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1"))," property."),(0,i.kt)("p",null,"Depending on the ",(0,i.kt)("a",{parentName:"p",href:"/z-devops-acceleration-program/docs/git-branching-model-for-mainframe-dev#workflows-in-this-branching-model"},"branching model workflow")," being used, the ",(0,i.kt)("inlineCode",{parentName:"p"},"mainBuildBranch")," property might need to be overridden for the feature branch pipeline:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In the ",(0,i.kt)("a",{parentName:"p",href:"/z-devops-acceleration-program/docs/git-branching-model-for-mainframe-dev#deliver-changes-with-the-next-planned-release"},"default development process")," working towards the next planned release based on the head of the ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," branch, the default configuration for the ",(0,i.kt)("inlineCode",{parentName:"p"},"mainBuildBranch")," is accurate and does not need to be overridden.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When ",(0,i.kt)("a",{parentName:"p",href:"/z-devops-acceleration-program/docs/git-branching-model-for-mainframe-dev#implement-a-fix-for-the-current-production-state"},"implementing a fix in context of a release maintenance branch"),", the ",(0,i.kt)("inlineCode",{parentName:"p"},"mainBuildBranch")," must be set to the name of the release maintenance branch to correctly clone the dependency information.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When ",(0,i.kt)("a",{parentName:"p",href:"/z-devops-acceleration-program/docs/git-branching-model-for-mainframe-dev#use-an-epic-branch-for-a-significant-development-initiative"},"implementing changes on a feature branch in an epic branch context"),", the ",(0,i.kt)("inlineCode",{parentName:"p"},"mainBuildBranch")," property must be set to the name of the epic branch."))),(0,i.kt)("p",null,"Instead of manipulating the property file that defines the ",(0,i.kt)("inlineCode",{parentName:"p"},"mainBuildBranch")," setting and is part of the repository, the pipeline automation can compute the correct setting and pass the overriding property via the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/IBM/dbb-zappbuild/blob/3.3.0/docs/BUILD.md#dynamically-overwrite-build-properties"},"override command-line option")," of zAppBuild."),(0,i.kt)("h3",{id:"package-and-deploy-a-feature-for-testing-in-controlled-test-environments"},"Package and Deploy a feature for testing in controlled test environments"),(0,i.kt)("p",null,"Today's mainframe development workflows can allow developers to install their changes into controlled test environments before these changes get assigned into a release, for instance when the developer would like to prototype/pilot a new feature. On lower environments, there might be multiple CICS regions that developers can use, which provide a level of isolation from other ongoing development work. The pipeline process can be extended to provide a similar functionality as an optional step for the developer."),(0,i.kt)("p",null,"This strategy is supported by feature branch packaging and deployment of a preliminary package. It is implemented as a dedicated pipeline that developers request on demand for their feature branch. The pipeline performs the following actions:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Build all the changes of the feature branch that were implemented, including their impacts as outlined in ",(0,i.kt)("a",{parentName:"li",href:"#basic-build-pipeline-build-and-test-stage"},"Basic Build Pipeline: Build and Test stage"),", using the commit point at which the feature branch was branched off as the baseline reference for calculating the changes."),(0,i.kt)("li",{parentName:"ol"},"Package the generated build outputs as outlined in ",(0,i.kt)("a",{parentName:"li",href:"#release-pipeline-packaging-stage"},"Release Pipeline: Packaging stage"),".")),(0,i.kt)("p",null,"The deployment process must ensure that these preliminary packages cannot be deployed into any production environment."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Diagram showing optional feature branch packaging and deployment of a preliminary package",src:a(6286).Z,width:"674",height:"270"})),(0,i.kt)("p",null,"Often, these controlled development test environments are used as shared test environments for multiple application teams. To use the same runtime environment, such as a CICS region, for both prototyping and for testing integrated changes, we recommend separating the preliminary (feature) packages from the planned release packages by separating these types into different libraries. The package for the prototyping workflow is deployed via its dedicated deployment environment model, illustrated in the above diagram as DEV-1-FEATURE-TEST."),(0,i.kt)("p",null,"Because preliminary packages are intended to be short-lived and temporary, they can be deployed to a library via the deployment automation process to a pre-concatenated library. Housekeeping strategies must be established to ensure that either automation routines or developers are cleaning up the preliminary packages when the testing is done."),(0,i.kt)("p",null,"This strategy should be designed with the infrastructure engineering team to prepare the test environments to support this workflow."),(0,i.kt)("h3",{id:"housekeeping-recommendations"},"Housekeeping recommendations"),(0,i.kt)("p",null,"A housekeeping strategy should be implemented when the feature branch is no longer needed and therefore removed from the central Git provider. Successful merging adds commits from one branch to the head of another. Once complete, the branch the commits were merged from can be safely deleted. (Keeping old branches can cause confusion and does not contribute to the traceability of the history.) This housekeeping strategy should include the cleanup of the DBB collections, the build workspace on z/OS UNIX System Services, and the build datasets."),(0,i.kt)("p",null,"Specific scripts can be integrated into the pipeline to delete ",(0,i.kt)("a",{parentName:"p",href:"https://www.ibm.com/docs/en/dbb/2.0?topic=interface-collection-commands#collection-delete"},"collections")," and ",(0,i.kt)("a",{parentName:"p",href:"https://www.ibm.com/docs/en/dbb/2.0?topic=interface-build-group-commands#build-group-delete"},"build groups"),", or ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/IBM/dbb/tree/main/Utilities/DeletePDS"},"remove unnecessary build datasets"),". When leveraging GitLab CI/CD as the pipeline orchestrator, the use of GitLab environments helps to automate these steps when a branch is deleted. An implementation sample is provided via the published technical document ",(0,i.kt)("a",{parentName:"p",href:"https://www.ibm.com/support/pages/integrating-ibm-zos-platform-cicd-pipelines-gitlab"},"Integrating IBM z/OS Platform in CI/CD Pipelines with Gitlab"),". Generally, webhooks and other extensions of the pipeline orchestrator can be leveraged to perform these cleanup activities when a branch is deleted."),(0,i.kt)("h2",{id:"the-basic-build-pipeline-for-main-epic-and-release-branches"},"The Basic Build Pipeline for main, epic, and release branches"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Branching diagram with build pipeline on the main branch",src:a(9581).Z,width:"674",height:"141"})),(0,i.kt)("p",null,"It is common practice to build every time the head of the ",(0,i.kt)("inlineCode",{parentName:"p"},"main"),", epic, or release branch is modified."),(0,i.kt)("p",null,"When a feature branch is merged into a shared integration branch, a new pipeline is kicked off to build the merged changes in the context of the configuration of the integration branch."),(0,i.kt)("p",null,"Additional steps such as automated code reviews or updates of application discovery repositories can be included in the pipeline process, as shown in the sample pipeline setup in the following screen capture."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Screen capture of a build pipeline for the main branch",src:a(3278).Z,width:"490",height:"199"})),(0,i.kt)("h3",{id:"basic-build-pipeline-build-and-test-stage"},"Basic Build Pipeline: Build and Test stage"),(0,i.kt)("p",null,"The purpose of the Build and Test stage of the pipeline for an integration branch is to ensure that the branch can be built and then tested together. It might happen that some features have indirect dependencies on other features planned for the same deliverable. This early point of integration along with the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/IBM/dbb-zappbuild/blob/3.2.0/docs/BUILD.md#perform-impact-build"},"impact build capability")," of the zAppBuild build framework ensures consistency and transparency for the upcoming deliverable."),(0,i.kt)("p",null,"Conceptually speaking, the build step of a CI/CD pipeline decouples building from deploying. This is important to ensure that only outputs from successful builds are installed into the test environment, rather than directing the build framework to update the libraries of the test environment directly."),(0,i.kt)("p",null,"The Build and Test stage of the pipeline for the integration branch builds all the incorporated changes that have so far been merged for the deliverable. To identify the list of changes contributing to the next planned release, the release maintenance, or the epic, the build step of the pipeline leverages the ",(0,i.kt)("inlineCode",{parentName:"p"},"--baselineRef")," option of zAppBuild for incremental builds, which is used to specify a baseline hash or point in the commit history for calculating the list of changes. Using this approach of incremental builds avoids unnecessarily building parts of the application that are unaffected by any of the changes in the commits to the base branch since the last release."),(0,i.kt)("p",null,"Additionally, the pipeline configuration requires a dedicated high-level qualifier to guarantee that build data sets are exclusively used for the provided branch. The value is passed to the zAppBuild command via the ",(0,i.kt)("inlineCode",{parentName:"p"},"--hlq")," parameter."),(0,i.kt)("p",null,"The option ",(0,i.kt)("inlineCode",{parentName:"p"},"--baselineRef")," is a sub-parameter of the ",(0,i.kt)("inlineCode",{parentName:"p"},"--impactBuild")," option in zAppBuild, and sets the base Git hash upon which the ",(0,i.kt)("inlineCode",{parentName:"p"},"git diff")," command calculates changes for the repository",(0,i.kt)("sup",{parentName:"p",id:"fnref-2"},(0,i.kt)("a",{parentName:"sup",href:"#fn-2",className:"footnote-ref"},"2")),"."),(0,i.kt)("p",null,"In the ",(0,i.kt)("a",{parentName:"p",href:"/z-devops-acceleration-program/docs/git-branching-model-for-mainframe-dev#deliver-changes-with-the-next-planned-release"},"default workflow")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," as the base branch, the baseline reference is defined by the commit hash (or the Git tag) of the previous release (that is, the release currently in production). In the following diagram, the blue dotted line shows the changes calculated from the baseline to the point at which the ",(0,i.kt)("inlineCode",{parentName:"p"},"feature_2")," branch is merged in."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Diagram showing the calculation of changes for the next planned release",src:a(7285).Z,width:"502",height:"260"})),(0,i.kt)("p",null,"For the ",(0,i.kt)("a",{parentName:"p",href:"/z-devops-acceleration-program/docs/git-branching-model-for-mainframe-dev#implement-a-fix-for-the-current-production-state"},"hotfix workflow"),", the hotfixes are planned to be implemented from a release maintenance branch whose baseline reference is the commit (or Git tag) that represents the state of the repository for the release. This is also the commit from which the respective release maintenance branch was created, as depicted in the below diagram."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Diagram showing the calculation of changes in a release fix workflow",src:a(7423).Z,width:"501",height:"423"})),(0,i.kt)("p",null,"For the ",(0,i.kt)("a",{parentName:"p",href:"/z-devops-acceleration-program/docs/git-branching-model-for-mainframe-dev#characteristics-of-mainline-based-development-with-feature-branches"},"epic branch workflow"),", the baseline reference for the build pipeline is the commit (or Release tag) from which the epic branch was created, also referred to as the fork point."),(0,i.kt)("h3",{id:"basic-build-pipeline-install-outputs-to-a-development-and-test-environment"},"Basic Build Pipeline: Install outputs to a development and test environment"),(0,i.kt)("p",null,"In this phase of the development lifecycle for the ",(0,i.kt)("a",{parentName:"p",href:"/z-devops-acceleration-program/docs/git-branching-model-for-mainframe-dev#deliver-changes-with-the-next-planned-release"},"default workflow")," implementing and delivering changes for the next planned release, the build typically operates with the compile options to enable ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/IBM/dbb-zappbuild/blob/3.3.0/docs/BUILD.md#common-pipeline-invocation-examples"},"testing and debugging")," of programs. As most organizations restrict the deployment to the production environments with optimized code only, these build artifacts can be seen as temporary and only for initial testing and debugging purposes."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Branching diagram with build pipeline on the main branch producing a preliminary package for the development and test environment",src:a(6721).Z,width:"678",height:"247"}),(0,i.kt)("br",{parentName:"p"}),"\n","There are two options to deploy the generated artifacts to the shared development test system - represented by the blue DEV-TEST shape in the above figure."),(0,i.kt)("p",null,"(Recommended) Option A: Extend the pipeline with a packaging stage and a deployment stage to create a preliminary package similar to ",(0,i.kt)("a",{parentName:"p",href:"#release-pipeline-packaging-stage"},"Release Pipeline: Packaging stage"),". It is traditionally the responsibility of the deployment solution to install the preliminary package into different environments. Doing so in this phase of the workflow will give the necessary traceability to understand which versions are installed in the development and test environment."),(0,i.kt)("p",null,"Option B: Use a post-build script to copy the output artifacts from the build libraries to the associated target runtime libraries and manually run the necessary activation steps such as a Db2 bind process or an online refresh. However, even given the temporary nature of the outputs created by this build, this circumvents the formal packaging and deployment process. The major drawback of this approach is a lack of traceability and understanding of what runs on the development and test environment."),(0,i.kt)("p",null,"This step of the build pipeline is also applicable for pipelines for the epic or the release maintenance branches."),(0,i.kt)("h3",{id:"basic-build-pipeline-analyze-stage"},"Basic Build Pipeline: Analyze stage"),(0,i.kt)("p",null,"An optional Analyze stage after building the most current state of the ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," branch can include steps to perform automated code inspections using the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/IBM/dbb/tree/v2.0.0/Pipeline/RunIDZCodeReview"},"IDz Code Review feature")," and/or to update the static code analysis repository such as in ",(0,i.kt)("a",{parentName:"p",href:"https://www.ibm.com/docs/en/addi/6.1.2?topic=wazi-analyze-user-guide"},"IBM Wazi Analyze"),"."),(0,i.kt)("p",null,"Submitting a Sonarqube scan at this point of the workflow can also help the development team to keep an eye on the maintainability and serviceability of the application."),(0,i.kt)("h2",{id:"the-release-pipeline-with-build-packaging-and-deploy-stages"},"The Release Pipeline with Build, Packaging, and Deploy stages"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Diagram showing the Release Pipeline building a release candidate package for deployment in test environments",src:a(3415).Z,width:"278",height:"267"}),"  "),(0,i.kt)("p",null,"The Release Pipeline is leveraged by the development team when they want to create a release candidate package that can be deployed to controlled test environments. The development team manually requests the pipeline to run. The pipeline is not expected to be used for every merge into the ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," branch."),(0,i.kt)("p",null,"The Release Pipeline differs from the previously-discussed pipelines and includes additional steps: after the stages of building and code scans have successfully completed, the pipeline packages all the incorporated changes of all merged features for this deliverable to create a package."),(0,i.kt)("p",null,"The package can be an intermediate release candidate version that can already be tested in the managed test environments, as outlined in the ",(0,i.kt)("a",{parentName:"p",href:"/z-devops-acceleration-program/docs/git-branching-model-for-mainframe-dev#workflows-in-this-branching-model"},"high-level workflows"),". When the development team has implemented all the tasks planned for the iteration, this same pipeline is used to produce the package that will be deployed to production."),(0,i.kt)("p",null,"The following diagram outlines the steps of a GitLab pipeline for the Build, Packaging, and Deploy stages."),(0,i.kt)("p",null,"The Deploy stage can only be present in the pipeline for the default workflow (with ",(0,i.kt)("inlineCode",{parentName:"p"},"main"),") when delivering changes with the next planned release, because the pipeline is unaware of the assigned environments for the epic and release maintenance workflows."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Build, package and deploy pipeline",src:a(4230).Z,width:"2548",height:"338"})),(0,i.kt)("h3",{id:"release-pipeline-build-stage"},"Release Pipeline: Build stage"),(0,i.kt)("p",null,"Similar to the build pipeline outlined in ",(0,i.kt)("a",{parentName:"p",href:"#basic-build-pipeline-build-and-test-stage"},"Basic Build Pipeline: Build and Test stage"),", the Build stage of the Release Pipeline builds all the incorporated changes of all merged features. To identify the list of changes contributing to the deliverable, the Build stage of the pipeline leverages the ",(0,i.kt)("inlineCode",{parentName:"p"},"--baselineRef")," option of zAppBuild to detect all contributed changes based on rules outlined in ",(0,i.kt)("a",{parentName:"p",href:"#basic-build-pipeline-build-and-test-stage"},"Basic Build Pipeline: Build and Test stage"),"."),(0,i.kt)("p",null,"For the ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," and the release maintenance workflows, this build performs the compilation with the compiler options to produce executables optimized for performance. The pipeline must leverage its dedicated set of PDS libraries to not interfere with the ",(0,i.kt)("a",{parentName:"p",href:"#the-basic-build-pipeline-for-main-epic-and-release-branches"},"Basic Build Pipeline"),"."),(0,i.kt)("p",null,"For the epic branch workflow, the build can occur with test options, as the package is only deployed into the initiative's test environment and will be rebuilt when the epic branch is integrated into the ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," branch."),(0,i.kt)("h3",{id:"release-pipeline-packaging-stage"},"Release Pipeline: Packaging stage"),(0,i.kt)("p",null,"The Packaging stage runs after the Build and Test stage, and creates a package of the generated build outputs (for example, load modules, DBRMs, and JCLs). This package includes the build outputs of all the contributed changes (including the files impacted by the changes) for the deliverable. It represents a release candidate that can be deployed into the various test environments along the existing staging hierarchy. As outlined in the high-level workflows, this can even happen when only a subset of the features for the deliverable is implemented."),(0,i.kt)("p",null,"The name or associated metadata of the package allows the development team to relate the package to the development workflow. Based on naming conventions of the package, different rules need to apply to its lifecycle. Some examples of this are shown below:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Use ",(0,i.kt)("inlineCode",{parentName:"p"},"rel-2.1.0_RC01")," for a release candidate package for the next planned release."),(0,i.kt)("p",{parentName:"li"},"  The package name represents the name of the next planned release. This package can make it to production, as it contains build outputs produced with options for optimization.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Use ",(0,i.kt)("inlineCode",{parentName:"p"},"rel-2.0.1-patch_RC01")," for an urgent fix package of the current production version."),(0,i.kt)("p",{parentName:"li"},'  This package is allowed to bypass any concurrent development activities and can take shortcuts in the route to production. For example, if it can only be tested on the QA-TEST environment, the developers can bypass lower test environments based on an "emergency" flag of the deployment package.')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Use ",(0,i.kt)("inlineCode",{parentName:"p"},"epic1-prelim_pkg01")," for a preliminary package of a long-running epic branch workflow."),(0,i.kt)("p",{parentName:"li"},"  This package can only be deployed to the assigned test environments available to the initiative, and cannot be deployed to production."))),(0,i.kt)("p",null,"The Packaging stage not only creates the binaries package, but it also carries information about the source code, such as the Git commit and additional links (including references to the pipeline job), which are helpful for understanding the context of the creation of the package."),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/IBM/dbb"},"DBB community repository")," contains two sample scripts that implement the Packaging stage. If IBM UrbanCode Deploy (UCD) is used as the deployment solution, the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/IBM/dbb/tree/main/Pipeline/CreateUCDComponentVersion"},(0,i.kt)("inlineCode",{parentName:"a"},"CreateUCDComponentVersion"))," script can be leveraged to create an IBM UrbanCode Deploy component version. Alternatively, if a scripted deployment is being set up, the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/IBM/dbb/tree/main/Pipeline/PackageBuildOutputs"},(0,i.kt)("inlineCode",{parentName:"a"},"PackageBuildOutputs"))," script can be used instead to store artifacts in an enterprise binary artifact repository leveraged by ",(0,i.kt)("a",{parentName:"p",href:"https://www.ibm.com/docs/en/developer-for-zos/16.0?topic=deploy-wazi-workflow"},"IBM Wazi Deploy"),"."),(0,i.kt)("p",null,"Both sample scripts leverage data from the DBB build report to extract and retain the metadata, allowing traceability between the build and deployment activities as outlined above."),(0,i.kt)("h3",{id:"release-pipeline-deploy-stage"},"Release Pipeline: Deploy stage"),(0,i.kt)("p",null,"The deployment process of a release package for the ",(0,i.kt)("a",{parentName:"p",href:"/z-devops-acceleration-program/docs/git-branching-model-for-mainframe-dev#deliver-changes-with-the-next-planned-release"},"default workflow with ",(0,i.kt)("inlineCode",{parentName:"a"},"main"))," can either be triggered from the CI/CD pipeline or driven through the user interface of the deployment manager. The implementation can vary based on the capabilities offered by the CI/CD orchestrator and the deployment solution. Deployment manager options for z/OS include IBM UrbanCode Deploy (UCD) and IBM Wazi Deploy."),(0,i.kt)("p",null,"IBM UrbanCode Deploy provides a rich web-based interface, powerful REST APIs, and a command-line interface. Typically, the pipeline execution requests the deployment of the application package into the defined test environments automatically, after successful completion of the preceding Build and Packaging stages. These requests are performed through the REST APIs provided by UCD. However, if the application team prefers to set up manual triggers for the deployments to the specific environments, this can be performed through UCD's web interface. In that scenario, the pipeline is primarily used for continuous integration and packaging."),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/IBM/dbb"},"DBB community repository")," provides a sample ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/IBM/dbb/tree/main/Pipeline/DeployUCDComponentVersion"},(0,i.kt)("inlineCode",{parentName:"a"},"DeployUCDComponentVersion"))," script that can be included in a pipeline process to request a UCD application deployment leveraging UCD's REST APIs."),(0,i.kt)("p",null,"IBM Wazi Deploy is a deployment manager for z/OS artifacts and comes with a command-line interface that can be easily invoked from a pipeline orchestrator and does not require a wrapper script. After retrieving the package to deploy from the artifact repository, the ",(0,i.kt)("inlineCode",{parentName:"p"},"wazideploy-generate")," step generates the deployment instructions (also known as the deployment plan) for the artifacts of the package. This plan is then passed to the ",(0,i.kt)("inlineCode",{parentName:"p"},"wazideploy-deploy")," step, which installs the contents of the package into the specified runtime environment",(0,i.kt)("sup",{parentName:"p",id:"fnref-3"},(0,i.kt)("a",{parentName:"sup",href:"#fn-3",className:"footnote-ref"},"3")),"."),(0,i.kt)("p",null,"The following screen capture shows the Deploy stage of a sample Release Pipeline."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Screen capture of the Deploy stage of the Release Pipeline",src:a(4152).Z,width:"359",height:"263"})),(0,i.kt)("p",null,"Implementation details of the Deploy stage can vary based on the pipeline orchestrator being used. In a GitLab CI/CD implementation, a pipeline can stay on hold and wait for user input. This allows the pipeline to automatically trigger the deployment of the application package into the first configured environment, and lets the application team decide when to deploy to the next environment through a manual step (for instance, deployment to the Acceptance environment)."),(0,i.kt)("p",null,"With Jenkins as the CI/CD orchestrator, it is not common to keep a pipeline in progress over a long time. In this case, the pipeline engineering team might consider the approach of requesting the deployments through the user interface of the deployment manager, or alternatively, they can design and set up a deployment pipeline in Jenkins that can combine the deployment with any automated tests or other automation tasks."),(0,i.kt)("h2",{id:"deployment-to-production"},"Deployment to production"),(0,i.kt)("p",null,"When the release candidate package has passed all quality gates and received all the necessary approvals, it is ready to be deployed to the production environment."),(0,i.kt)("p",null,"The release manager takes care of this step of the lifecycle and will leverage the user interface of the deployment manager, such as UCD's browser-based interface. In the case of a deployment manager solution with a command-line interface such as Wazi Deploy, the user interface of the pipeline orchestrator is used by the release manager to drive the deployment to production. A deployment pipeline definition needs to be configured to roll out the package."),(0,i.kt)("p",null,"Deploying to production consists of two tasks:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Invoke the deployment to the production runtime environment through either the deployment manager interface or a deployment pipeline definition.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Tag the commit in the Git server by assigning a Git tag to the commit that was used to build the release package."))),(0,i.kt)("p",null,"Most Git providers allow for the creation of a release to provide a summary of the changes, as well as additional documentation. ",(0,i.kt)("a",{parentName:"p",href:"https://docs.gitlab.com/ee/api/releases/"},"GitLab")," and ",(0,i.kt)("a",{parentName:"p",href:"https://docs.github.com/en/rest/releases/releases"},"GitHub")," offer REST APIs to create a new tag/release. This action should be automated as part of the deployment to production."),(0,i.kt)("p",null,"As an example of using Git tags, ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/IBM/dbb-zappbuild/releases/tag/3.2.0"},"zAppBuild")," also declares releases to identify stable versions."),(0,i.kt)("h2",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"This page provides guidance for implementing a ",(0,i.kt)("a",{parentName:"p",href:"/z-devops-acceleration-program/docs/git-branching-model-for-mainframe-dev"},"Git branching model for mainframe development")," with IBM Dependency Based Build and zAppBuild."),(0,i.kt)("p",null,"The CI/CD pipeline configurations that were outlined at various stages can be adjusted depending on the application team's existing and desired development processes and philosophy. Factors that might impact the design of the pipelines and workflow include test strategies, the number of test environments, and potential testing limitations."),(0,i.kt)("p",null,"When designing a CI/CD pipeline, assessment of current and future requirements in the software delivery lifecycle is key. As CI/CD technologies continue to evolve and automated testing using provisioned test environments becomes more common in mainframe application development teams, the outlined branching strategy can also evolve to maximize the benefits from these advances."),(0,i.kt)("div",{className:"footnotes"},(0,i.kt)("hr",{parentName:"div"}),(0,i.kt)("ol",{parentName:"div"},(0,i.kt)("li",{parentName:"ol",id:"fn-1"},"zAppBuild documentation: ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/IBM/dbb-zappbuild/blob/3.2.0/docs/BUILD.md#perform-impact-build-for-topic-branches"},"https://github.com/IBM/dbb-zappbuild/blob/3.2.0/docs/BUILD.md#perform-impact-build-for-topic-branches"),(0,i.kt)("a",{parentName:"li",href:"#fnref-1",className:"footnote-backref"},"\u21a9")),(0,i.kt)("li",{parentName:"ol",id:"fn-2"},"zAppBuild implementation to set ",(0,i.kt)("inlineCode",{parentName:"li"},"baselineRef"),": ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/IBM/dbb-zappbuild/blob/3.2.0/docs/BUILD.md#perform-impact-build-by-providing-baseline-reference-for-the-analysis-of-changed-files"},"https://github.com/IBM/dbb-zappbuild/blob/3.2.0/docs/BUILD.md#perform-impact-build-by-providing-baseline-reference-for-the-analysis-of-changed-files"),(0,i.kt)("a",{parentName:"li",href:"#fnref-2",className:"footnote-backref"},"\u21a9")),(0,i.kt)("li",{parentName:"ol",id:"fn-3"},"IBM Wazi Deploy static deployment workflow: ",(0,i.kt)("a",{parentName:"li",href:"https://www.ibm.com/docs/en/developer-for-zos/16.0?topic=deploy-getting-started-static-deployment"},"https://www.ibm.com/docs/en/developer-for-zos/16.0?topic=deploy-getting-started-static-deployment"),(0,i.kt)("a",{parentName:"li",href:"#fnref-3",className:"footnote-backref"},"\u21a9")))))}h.isMDXComponent=!0},7285:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/basicBuildPipeline-computeChanges-default-workflow-3e7428b28040328f01a8101016081724.png"},7423:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/basicBuildPipeline-computeChanges-fix-workflow-4d57aad14a9951ba43c7580cc1fa38c7.png"},6721:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/defaultWorkflow_buildPipelineAfterMerge-f4b4c0cafc3bfa64c830ec4237f18536.png"},3415:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/defaultWorkflow_releasePipeline_RC1_cropped-956bbdd96aff88d24b9ab00b07406558.png"},8877:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/image16-fd4902b75bf06f28d5bebd7a6aa15ddd.png"},3278:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/image17-11b42390ca62c6f9dbf734f1ad62d1a7.png"},6286:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/image18-96f1cedec1c3c863698aa31a22cebc53.png"},4230:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/image22-6ddd4491d678670898d6762a9b5d96b2.png"},4152:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/image23-6d1f02aeb08399a49df2d5a2457c883c.png"},9581:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/image6-85bba4e51ba9c22248c9e2dfbe19f608.png"}}]);